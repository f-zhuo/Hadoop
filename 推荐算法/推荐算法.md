# CB

Content Based，基于内容文本相似，只根据用户当前的行为（item）进行推荐，item可以是观看的视频，听的音乐。。。算法的输入数据格式一般为：user item

## 流程

用户行为-行为分析如分词-倒排建库-检索系统搜索token/item进行推荐

比如：用户正在观看“三国演义”，推荐系统对“三国演义”这个item进行分词处理，得到token1“三国”和token2“演义”，对应的score可以由tfidf计算得到，这个过程叫做正排。正排的结果从数据库（存储经不同召回算法计算的推荐结果）搜索，找到和token1，token2及其他存在相关性的token对应的item，返回给用户。由token得到item的过程叫做倒排，这一过程也是算法的核心，将在下文介绍。如token1->“三国志”:0.6，“三国群英传”：0.4；token2->“隋唐演义”：0.4，“明史演义”：0.4，“中国演义小说的发展历史”：0.2。推荐系统把”三国志”，“三国群英传”，“隋唐演义”，“明史演义”，“中国演义小说的发展历史”推荐给用户，还可能把“名著”这个相关token对应的item也推荐过去

优点：

* 可解释，用户可感知推荐理由

* 实时性好，不需要依据用户历史行为，有了item就能推荐

缺点：

* 基于内容，按item的字面意思进行的推荐，过于依赖字面含义，有可能造成语义缺失/错误。比如用户观看“三国演义”，推荐了“中国演义小说的发展历史”

* 不依赖用户的历史行为，没有个性化。不论观看者是谁，推荐内容都一样

解决个性化的方法：

在算法中加入对用户历史行为的分析，对用户以前观看过的item进行分词，根据分词结果推荐，和CB推荐结果合并

缺点：若用户行为稀疏，推荐效果差，出现马太效应（两极分化）

## 实现

### 倒排法

输入数据是token-item矩阵，计算token-token/item-item的相似度

计算相似度：

* 对token-item矩阵的score做归一化处理，求谁的相似度就对谁做归一化
* 计算余弦相似度

如：

| token\item |  A   |  B   |  C   |
| :--------: | :--: | :--: | :--: |
|     a      |  s1  |  s2  |  s3  |
|     b      |  s4  |  s5  |  s6  |
|     c      |  s7  |  s8  |  s9  |

*s1...是item和token之间的打分，这个值是由分词时计算TFIDF得到的*

计算itemA和B的相似度：
$$
sim(A,B)=\frac{A\cdot B}{\left | A \right |\left | B \right |}=\frac{s1*s2+s4*s5+s7*s8}{\sqrt{s1^{2}+s4^{2}+s7^{2}}*\sqrt{s2^{2}+s5^{2}+s8^{2}}}
$$
计算token a和b的相似度：
$$
sim(a,b)=\frac{a\cdot b}{\left | a \right |\left | b \right |}=\frac{s1*s4+s2*s5+s3*s6}{\sqrt{s1^{2}+s2^{2}+s3^{2}}*\sqrt{s4^{2}+s5^{2}+s6^{2}}}
$$
如果将sim(A,B)的算式拆成两部分来看
$$
sim(A,B)=\frac{A}{\left | A \right |}\cdot\frac{B}{\left | B \right |}=\frac{s1}{\sqrt{s1^{2}+s4^{2}+s7^{2}}}*\frac{s2}{\sqrt{s2^{2}+s5^{2}+s8^{2}}} \\ +\frac{s4}{\sqrt{s1^{2}+s4^{2}+s7^{2}}}*\frac{s5}{\sqrt{s2^{2}+s5^{2}+s8^{2}}} \\ +\frac{s7}{\sqrt{s1^{2}+s4^{2}+s7^{2}}}*\frac{s8}{\sqrt{s2^{2}+s5^{2}+s8^{2}}}
$$
结果是一样的，为了统一，第一步做归一化，然后直接点乘

对不同的item/token进行相似度计算，就可以得到一个item-item矩阵/token-token矩阵，其中的数字就是两者的相似度。得到了相似度，就可以对token/item做推荐，将相似度高的推荐出去

**倒排式的缺点**

在计算item-item相似度时，一般以同一个token的不同item做pair对，再按item的pair对将不同token聚合。若token已有n个item，每增加一个item，就多了n个pair对

解决方法是对token的item进行截取

### 分块法

目标也是要求取item-item/token-token的相似度，但方法不是余弦相似度，而是矩阵计算

将token-item矩阵转置，得到item-token矩阵，则`token-item*item-token`可得token-token矩阵，`item-token*token-item`可得item-item矩阵，对应的值可以认为是相似度。但矩阵计算复杂，内存占用大，所以把token-item矩阵按行分块，形成n个行向量，分别和item-token矩阵相乘，再将结果合并

**分块式的缺点**

将一个矩阵分块，但另一个矩阵未分块，占用内存资源大

# CF

Collaboration Filtering，基于协同的推荐算法，输入数据格式为：user->item：score，分两种：

* User-Based CF：基于其他人的行为做推荐

有两个假设：

1. 对用户分组，有相同兴趣爱好的人喜欢同样的东西

2. 用户的兴趣长期不变

方法：

找到用户的分组，把组内其他人喜欢的东西推荐给该用户

* Item-Based CF：基于自己的历史行为做推荐

有两个假设：

1. 用户喜欢和过去喜欢的物品相似的东西

2. 过去相似的物品将来也相似

方法：

找到某用户过去喜欢的物品集合，推荐相似物品

## 流程

对输入的UI矩阵做计算，得到item-item矩阵（item-based）或者user-user矩阵（user—based），即item/user间的相关性，直接推荐item（item-based）/user的item（user-based）即可

## 方法

同样，CF也可以用倒排或者分块，只不过计算的矩阵是user-item

已知：u-i矩阵

| user\item | item1  | item2  | item3  |
| :-------: | :----: | :----: | :----: |
|   user1   | score1 | score2 | score3 |
|   user2   | score4 |   ?    | score6 |
|   user3   | score7 | score8 | score9 |

 u-u矩阵

|       | user1 | user2 | user3 |
| :---: | :---: | :---: | :---: |
| user1 |   \   |  c12  |  c13  |
| user2 |  c12  |   \   |  c23  |
| user3 |  c13  |  c23  |   \   |

求：score5
$$
score5=\frac{c12*score2+c23*score8}{c12+c23}
$$

|                    |                     user_based                      |            item_based            |
| :----------------: | :-------------------------------------------------: | :------------------------------: |
|      适用场景      | user少，避免计算u-u相似矩阵代价大；用户个性化不明显 |      item少；用户个性化明显      |
|       实时性       |        不明显，用户新行为不一定立即引起变化         | 明显，用户新行为一定立即引起变化 |
| 推荐理由是否可感知 |                      不可感知                       |              可感知              |

CF的优点：

并不完全依赖item的字面意思，个性化，推荐精度高于CB

缺点：

* 实时性差，新商品/用户不能立即推荐

* 可解释性差，用户不一定理解当前推荐的理由

CB和CF算法的实现和思想其实一致，只是面向的对象不同：CB面向用户的当前行为，CF是面向用户的历史行为或是其他用户行为。两者的实现方法只是数据源不同，CB是item-token，CF是user-item

# 冷启动

用户是新注册的，物品是新上架的，数据不够，不足以做推荐

* 用户冷启动

  * 提供热门排行榜，收集用户一部分数据后再提供个性化推荐

  * 根据用户注册时提供的性别，年龄进行粗粒度划分

  * 注册时要求用户填写一些兴趣信息

  * 根据社交账号，推荐朋友喜欢的

* 物品冷启动
  * 推荐给喜欢类似物品的用户
  * 物品要在第一时间展现给用户

* 系统冷启动

 引入专家知识（人工标注），建立物品的相关矩阵



