聚类的目的是将数据划分到不同的类里，使相似的数据在同一类里，不相似的数据在不同类里，属于无监督算法

聚类算法可分为

* 硬聚类：该对象百分之百属于这个类

* 软聚类：该对象以某个概率属于多个类，由最大的概率确定类

还可分为层次聚类和非层次聚类

# 层次聚类

不同的类存在包含的关系

* 自底而上

从多个类合并到一个类，如A，B，C，D，E，F六个对象，按照距离远近两两合并，形成不同的新的类；接着按距离将新类两两合并，不断重复，最终形成一个类

* 自顶而下

最初只有一个类，层层分裂，最终形成N个类

距离计算公式以欧式距离为依据：

如点`(x1,x2)，(y1,y2)`，欧式距离为：$$D = \sqrt {(x1-y1)^2 + (x2-y2)^2}$$

有三种计算距离的方法：

* 单链：找各类之间的最短距离，大类的对象多，所以更可能距离最短。倾向于先聚大类，再聚小类

* 全链：找各类之间的最大距离，小类的对象少，所以最大距离可能更短。倾向于先聚小类，再聚大类

* 组合链：计算各类的平均距离，每个对象都参与计算

**Q：**层次聚类最终会将多个类合并成一个，那为什么要分层计算距离两两合并类，不直接合成一个呢？

**A**：在不同的层切割，可以得到不同数目的类，起到分成N类的效果

![](.\pictures\1.png)

层次聚类的算法复杂度：O(n^3)，其中n表示聚类对象个数

 # 非层次聚类

Kmeans：

* 任意选择 K 个点作为初始聚类中心
* 根据每个聚类的中心，计算每个对象与这些中心的距离，并根据最小距离重新对相应对象进行划分
* 重新计算每个聚类的中心
* 当满足一定条件，如类别划分不再发生变化/损失函数的变化小于某阈值时，算法终止，否则重复上述步骤 2 和 3 

损失函数： 各簇的中心点/质心到每个对象的距离平方和

![](.\pictures\WCSS.png)

kmeans很依赖中心点的选择，可以随机选取，也可以采用多轮随机选取：选择损失函数最小的几个

时间复杂度：O(nkt)，其中n表示聚类对象个数，k表示类的个数， t表示迭代次数

Kmeans算法计算慢，初始点选择对结果影响大，不能对非凸的簇起作用，只能保证局部最优无法保证全局最优，但实现简单

## 评价方法

好的聚类方法应该具备高的类内相似度，低的类间相似度，一般有两个评估标准：

* 内部评价法：没有监督，没有外部标准，判断的依据是同类是否相似，跨类是否相异
* 外部评价法：有外部标准，有监督，判断方法是和外部标准是否一致  